import"reflect-metadata";export{LazyServiceIdentifier}from"@inversifyjs/common";import{getTargets as t,getClassElementMetadataFromLegacyMetadata as n,ClassElementMetadataKind as e,LegacyTargetImpl as i}from"@inversifyjs/core";const r="named",s="name",o="unmanaged",a="optional",c="inject",d="multi_inject",u="inversify:tagged",h="inversify:tagged_props",l="inversify:paramtypes",g="design:paramtypes",y="post_construct",p="pre_destroy";const f=[c,d,s,o,r,a];var _=Object.freeze({__proto__:null,DESIGN_PARAM_TYPES:g,INJECT_TAG:c,MULTI_INJECT_TAG:d,NAMED_TAG:r,NAME_TAG:s,NON_CUSTOM_TAG_KEYS:f,OPTIONAL_TAG:a,PARAM_TYPES:l,POST_CONSTRUCT:y,PRE_DESTROY:p,TAGGED:u,TAGGED_PROP:h,UNMANAGED_TAG:o});const v={Request:"Request",Singleton:"Singleton",Transient:"Transient"},b={ConstantValue:"ConstantValue",Constructor:"Constructor",DynamicValue:"DynamicValue",Factory:"Factory",Function:"Function",Instance:"Instance",Invalid:"Invalid",Provider:"Provider"},w={ClassProperty:"ClassProperty",ConstructorArgument:"ConstructorArgument",Variable:"Variable"};let m=0;function A(){return m++}class S{id;moduleId;activated;serviceIdentifier;implementationType;cache;dynamicValue;scope;type;factory;provider;constraint;onActivation;onDeactivation;constructor(t,n){this.id=A(),this.activated=!1,this.serviceIdentifier=t,this.scope=n,this.type=b.Invalid,this.constraint=t=>!0,this.implementationType=null,this.cache=null,this.factory=null,this.provider=null,this.onActivation=null,this.onDeactivation=null,this.dynamicValue=null}clone(){const t=new S(this.serviceIdentifier,this.scope);return t.activated=t.scope===v.Singleton&&this.activated,t.implementationType=this.implementationType,t.dynamicValue=this.dynamicValue,t.scope=this.scope,t.type=this.type,t.factory=this.factory,t.provider=this.provider,t.constraint=this.constraint,t.onActivation=this.onActivation,t.onDeactivation=this.onDeactivation,t.cache=this.cache,t}}const I="Metadata key was used more than once in a parameter:",T="NULL argument",D="Key Not Found",N="Ambiguous match found for serviceIdentifier:",C="No matching bindings found for serviceIdentifier:",x="The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.",R=(t,n)=>`onDeactivation() error in class ${t}: ${n}`;class E{getConstructorMetadata(t){return{compilerGeneratedMetadata:Reflect.getMetadata(g,t)??[],userGeneratedMetadata:Reflect.getMetadata(u,t)??{}}}getPropertiesMetadata(t){return Reflect.getMetadata(h,t)??{}}}var M;function B(t){return t instanceof RangeError||"Maximum call stack size exceeded"===t.message}!function(t){t[t.MultipleBindingsAvailable=2]="MultipleBindingsAvailable",t[t.NoBindingsAvailable=0]="NoBindingsAvailable",t[t.OnlyOneBindingAvailable=1]="OnlyOneBindingAvailable"}(M||(M={}));function P(t){return"function"==typeof t?t.name:"symbol"==typeof t?t.toString():t}function k(t,n,e){let i="";const r=e(t,n);return 0!==r.length&&(i="\nRegistered bindings:",r.forEach((t=>{let n="Object";null!==t.implementationType&&(n=j(t.implementationType)),i=`${i}\n ${n}`,t.constraint.metaData&&(i=`${i} - ${t.constraint.metaData}`)}))),i}function q(t,n){return null!==t.parentRequest&&(t.parentRequest.serviceIdentifier===n||q(t.parentRequest,n))}function F(t){t.childRequests.forEach((n=>{if(q(t,n.serviceIdentifier)){const t=function(t){const n=function t(n,e=[]){const i=P(n.serviceIdentifier);return e.push(i),null!==n.parentRequest?t(n.parentRequest,e):e}(t);return n.reverse().join(" --\x3e ")}(n);throw new Error(`Circular dependency found: ${t}`)}F(n)}))}function j(t){if(null!=t.name&&""!==t.name)return t.name;{const n=t.toString(),e=n.match(/^function\s*([^\s(]+)/);return null===e?`Anonymous function: ${n}`:e[1]}}function O(t){return`{"key":"${t.key.toString()}","value":"${t.value.toString()}"}`}class ${id;container;plan;currentRequest;constructor(t){this.id=A(),this.container=t}addPlan(t){this.plan=t}setCurrentRequest(t){this.currentRequest=t}}class V{key;value;constructor(t,n){this.key=t,this.value=n}toString(){return this.key===r?`named: ${String(this.value).toString()} `:`tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`}}class W{parentContext;rootRequest;constructor(t,n){this.parentContext=t,this.rootRequest=n}}function G(n,e){const i=function(t){const n=Object.getPrototypeOf(t.prototype),e=n?.constructor;return e}(e);if(void 0===i||i===Object)return 0;const r=t(n)(i),s=r.map((t=>t.metadata.filter((t=>t.key===o)))),a=[].concat.apply([],s).length,c=r.length-a;return c>0?c:G(n,i)}class K{id;serviceIdentifier;parentContext;parentRequest;bindings;childRequests;target;requestScope;constructor(t,n,e,i,r){this.id=A(),this.serviceIdentifier=t,this.parentContext=n,this.parentRequest=e,this.target=r,this.childRequests=[],this.bindings=Array.isArray(i)?i:[i],this.requestScope=null===e?new Map:null}addChildRequest(t,n,e){const i=new K(t,this.parentContext,this,n,e);return this.childRequests.push(i),i}}function H(t){return t._bindingDictionary}function U(t,n,e,i,r){let s=z(e.container,r.serviceIdentifier),o=[];return s.length===M.NoBindingsAvailable&&!0===e.container.options.autoBindInjectable&&"function"==typeof r.serviceIdentifier&&t.getConstructorMetadata(r.serviceIdentifier).compilerGeneratedMetadata&&(e.container.bind(r.serviceIdentifier).toSelf(),s=z(e.container,r.serviceIdentifier)),o=n?s:s.filter((t=>{const n=new K(t.serviceIdentifier,e,i,t,r);return t.constraint(n)})),function(t,n,e,i,r){switch(n.length){case M.NoBindingsAvailable:if(i.isOptional())return n;{const n=P(t);let s=C;throw s+=function(t,n){if(n.isTagged()||n.isNamed()){let e="";const i=n.getNamedTag(),r=n.getCustomTags();return null!==i&&(e+=O(i)+"\n"),null!==r&&r.forEach((t=>{e+=O(t)+"\n"})),` ${t}\n ${t} - ${e}`}return` ${t}`}(n,i),s+=k(r,n,z),null!==e&&(s+="\n"+`Trying to resolve bindings for "${P(e.serviceIdentifier)}"`),new Error(s)}case M.OnlyOneBindingAvailable:return n;case M.MultipleBindingsAvailable:default:if(i.isArray())return n;{const n=P(t);let e=`${N} ${n}`;throw e+=k(r,n,z),new Error(e)}}}(r.serviceIdentifier,o,i,r,e.container),o}function L(t,n){const e=n.isMultiInject?d:c,i=[new V(e,t)];return void 0!==n.customTag&&i.push(new V(n.customTag.key,n.customTag.value)),!0===n.isOptional&&i.push(new V(a,!0)),i}function Y(n,e,i,r,s,o){let a,c;if(null===s){a=U(n,e,r,null,o),c=new K(i,r,null,a,o);const t=new W(r,c);r.addPlan(t)}else a=U(n,e,r,s,o),c=s.addChildRequest(o.serviceIdentifier,a,o);a.forEach((e=>{let i=null;if(o.isArray())i=c.addChildRequest(e.serviceIdentifier,e,o);else{if(null!==e.cache)return;i=c}if(e.type===b.Instance&&null!==e.implementationType){const s=function(n,e){return t(n)(e)}(n,e.implementationType);if(!0!==r.container.options.skipBaseClassChecks){const t=G(n,e.implementationType);if(s.length<t){const t=`The number of constructor arguments in the derived class ${j(e.implementationType)} must be >= than the number of constructor arguments of its base class.`;throw new Error(t)}}s.forEach((t=>{Y(n,!1,t.serviceIdentifier,r,i,t)}))}}))}function z(t,n){let e=[];const i=H(t);return i.hasKey(n)?e=i.get(n):null!==t.parent&&(e=z(t.parent,n)),e}function J(t,r,s,o,a,c=!1){const d=new $(r),u=function(t,r,s){const o=L(r,s),a=n(o);if(a.kind===e.unmanaged)throw new Error("Unexpected metadata when creating target");return new i("",a,t)}(s,o,a);try{return Y(t,c,o,d,null,u),d}catch(t){throw B(t)&&F(d.plan.rootRequest),t}}function Q(t){return("object"==typeof t&&null!==t||"function"==typeof t)&&"function"==typeof t.then}function X(t){return!!Q(t)||Array.isArray(t)&&t.some(Q)}const Z=(t,n,e)=>{t.has(n.id)||t.set(n.id,e)},tt=(t,n)=>{t.cache=n,t.activated=!0,Q(n)&&nt(t,n)},nt=async(t,n)=>{try{const e=await n;t.cache=e}catch(n){throw t.cache=null,t.activated=!1,n}};var et;!function(t){t.DynamicValue="toDynamicValue",t.Factory="toFactory",t.Provider="toProvider"}(et||(et={}));const it=t=>n=>(...e)=>{e.forEach((e=>{t.bind(e).toService(n)}))};function rt(t,n,e){let i;if(n.length>0){const r=function(t,n){return t.reduce(((t,e)=>{const i=n(e);return e.target.type===w.ConstructorArgument?t.constructorInjections.push(i):(t.propertyRequests.push(e),t.propertyInjections.push(i)),t.isAsync||(t.isAsync=X(i)),t}),{constructorInjections:[],isAsync:!1,propertyInjections:[],propertyRequests:[]})}(n,e),s={...r,constr:t};i=r.isAsync?async function(t){const n=await ot(t.constructorInjections),e=await ot(t.propertyInjections);return st({...t,constructorInjections:n,propertyInjections:e})}(s):st(s)}else i=new t;return i}function st(t){const n=new t.constr(...t.constructorInjections);return t.propertyRequests.forEach(((e,i)=>{const r=e.target.identifier,s=t.propertyInjections[i];e.target.isOptional()&&void 0===s||(n[r]=s)})),n}async function ot(t){const n=[];for(const e of t)Array.isArray(e)?n.push(Promise.all(e)):n.push(e);return Promise.all(n)}function at(t,n){const e=function(t,n){if(Reflect.hasMetadata(y,t)){const r=Reflect.getMetadata(y,t);try{return n[r.value]?.()}catch(n){if(n instanceof Error)throw new Error((e=t.name,i=n.message,`@postConstruct error in class ${e}: ${i}`))}}var e,i}(t,n);return Q(e)?e.then((()=>n)):n}function ct(t,n){t.scope!==v.Singleton&&function(t,n){const e=`Class cannot be instantiated in ${t.scope===v.Request?"request":"transient"} scope.`;if("function"==typeof t.onDeactivation)throw new Error(R(n.name,e));if(Reflect.hasMetadata(p,n))throw new Error(`@preDestroy error in class ${n.name}: ${e}`)}(t,n)}const dt=t=>n=>{n.parentContext.setCurrentRequest(n);const e=n.bindings,i=n.childRequests,r=n.target&&n.target.isArray(),s=!(n.parentRequest&&n.parentRequest.target&&n.target&&n.parentRequest.target.matchesArray(n.target.serviceIdentifier));if(r&&s)return i.map((n=>dt(t)(n)));{if(n.target.isOptional()&&0===e.length)return;const i=e[0];return gt(t,n,i)}},ut=(t,n)=>{const e=(t=>{switch(t.type){case b.Factory:return{factory:t.factory,factoryType:et.Factory};case b.Provider:return{factory:t.provider,factoryType:et.Provider};case b.DynamicValue:return{factory:t.dynamicValue,factoryType:et.DynamicValue};default:throw new Error(`Unexpected factory type ${t.type}`)}})(t);return((t,n)=>{try{return t()}catch(t){if(B(t))throw n();throw t}})((()=>e.factory.bind(t)(n)),(()=>{return new Error((t=e.factoryType,i=n.currentRequest.serviceIdentifier.toString(),`It looks like there is a circular dependency in one of the '${t}' bindings. Please investigate bindings with service identifier '${i}'.`));var t,i}))},ht=(t,n,e)=>{let i;const r=n.childRequests;switch((t=>{let n=null;switch(t.type){case b.ConstantValue:case b.Function:n=t.cache;break;case b.Constructor:case b.Instance:n=t.implementationType;break;case b.DynamicValue:n=t.dynamicValue;break;case b.Provider:n=t.provider;break;case b.Factory:n=t.factory}if(null===n){const n=P(t.serviceIdentifier);throw new Error(`Invalid binding type: ${n}`)}})(e),e.type){case b.ConstantValue:case b.Function:i=e.cache;break;case b.Constructor:i=e.implementationType;break;case b.Instance:i=function(t,n,e,i){ct(t,n);const r=rt(n,e,i);return Q(r)?r.then((t=>at(n,t))):at(n,r)}(e,e.implementationType,r,dt(t));break;default:i=ut(e,n.parentContext)}return i},lt=(t,n,e)=>{let i=((t,n)=>n.scope===v.Singleton&&n.activated?n.cache:n.scope===v.Request&&t.has(n.id)?t.get(n.id):null)(t,n);return null!==i||(i=e(),((t,n,e)=>{n.scope===v.Singleton&&tt(n,e),n.scope===v.Request&&Z(t,n,e)})(t,n,i)),i},gt=(t,n,e)=>lt(t,e,(()=>{let i=ht(t,n,e);return i=Q(i)?i.then((t=>yt(n,e,t))):yt(n,e,i),i}));function yt(t,n,e){let i=pt(t.parentContext,n,e);const r=bt(t.parentContext.container);let s,o=r.next();do{s=o.value;const n=t.parentContext,e=t.serviceIdentifier,a=vt(s,e);i=Q(i)?_t(a,n,i):ft(a,n,i),o=r.next()}while(!0!==o.done&&!H(s).hasKey(t.serviceIdentifier));return i}const pt=(t,n,e)=>{let i;return i="function"==typeof n.onActivation?n.onActivation(t,e):e,i},ft=(t,n,e)=>{let i=t.next();for(;!0!==i.done;){if(Q(e=i.value(n,e)))return _t(t,n,e);i=t.next()}return e},_t=async(t,n,e)=>{let i=await e,r=t.next();for(;!0!==r.done;)i=await r.value(n,i),r=t.next();return i},vt=(t,n)=>{const e=t._activations;return e.hasKey(n)?e.get(n).values():[].values()},bt=t=>{const n=[t];let e=t.parent;for(;null!==e;)n.push(e),e=e.parent;return{next:()=>{const t=n.pop();return void 0!==t?{done:!1,value:t}:{done:!0,value:void 0}}}};const wt=(t,n)=>{const e=t.parentRequest;return null!==e&&(!!n(e)||wt(e,n))},mt=t=>n=>{const e=e=>null!==e&&null!==e.target&&e.target.matchesTag(t)(n);return e.metaData=new V(t,n),e},At=mt(r),St=t=>n=>{let e=null;if(null!==n){if(e=n.bindings[0],"string"==typeof t)return e.serviceIdentifier===t;{const e=n.bindings[0].implementationType;return t===e}}return!1};class It{_binding;constructor(t){this._binding=t}when(t){return this._binding.constraint=t,new Tt(this._binding)}whenTargetNamed(t){return this._binding.constraint=At(t),new Tt(this._binding)}whenTargetIsDefault(){return this._binding.constraint=t=>{if(null===t)return!1;return null!==t.target&&!t.target.isNamed()&&!t.target.isTagged()},new Tt(this._binding)}whenTargetTagged(t,n){return this._binding.constraint=mt(t)(n),new Tt(this._binding)}whenInjectedInto(t){return this._binding.constraint=n=>null!==n&&St(t)(n.parentRequest),new Tt(this._binding)}whenParentNamed(t){return this._binding.constraint=n=>null!==n&&At(t)(n.parentRequest),new Tt(this._binding)}whenParentTagged(t,n){return this._binding.constraint=e=>null!==e&&mt(t)(n)(e.parentRequest),new Tt(this._binding)}whenAnyAncestorIs(t){return this._binding.constraint=n=>null!==n&&wt(n,St(t)),new Tt(this._binding)}whenNoAncestorIs(t){return this._binding.constraint=n=>null!==n&&!wt(n,St(t)),new Tt(this._binding)}whenAnyAncestorNamed(t){return this._binding.constraint=n=>null!==n&&wt(n,At(t)),new Tt(this._binding)}whenNoAncestorNamed(t){return this._binding.constraint=n=>null!==n&&!wt(n,At(t)),new Tt(this._binding)}whenAnyAncestorTagged(t,n){return this._binding.constraint=e=>null!==e&&wt(e,mt(t)(n)),new Tt(this._binding)}whenNoAncestorTagged(t,n){return this._binding.constraint=e=>null!==e&&!wt(e,mt(t)(n)),new Tt(this._binding)}whenAnyAncestorMatches(t){return this._binding.constraint=n=>null!==n&&wt(n,t),new Tt(this._binding)}whenNoAncestorMatches(t){return this._binding.constraint=n=>null!==n&&!wt(n,t),new Tt(this._binding)}}class Tt{_binding;constructor(t){this._binding=t}onActivation(t){return this._binding.onActivation=t,new It(this._binding)}onDeactivation(t){return this._binding.onDeactivation=t,new It(this._binding)}}class Dt{_bindingWhenSyntax;_bindingOnSyntax;_binding;constructor(t){this._binding=t,this._bindingWhenSyntax=new It(this._binding),this._bindingOnSyntax=new Tt(this._binding)}when(t){return this._bindingWhenSyntax.when(t)}whenTargetNamed(t){return this._bindingWhenSyntax.whenTargetNamed(t)}whenTargetIsDefault(){return this._bindingWhenSyntax.whenTargetIsDefault()}whenTargetTagged(t,n){return this._bindingWhenSyntax.whenTargetTagged(t,n)}whenInjectedInto(t){return this._bindingWhenSyntax.whenInjectedInto(t)}whenParentNamed(t){return this._bindingWhenSyntax.whenParentNamed(t)}whenParentTagged(t,n){return this._bindingWhenSyntax.whenParentTagged(t,n)}whenAnyAncestorIs(t){return this._bindingWhenSyntax.whenAnyAncestorIs(t)}whenNoAncestorIs(t){return this._bindingWhenSyntax.whenNoAncestorIs(t)}whenAnyAncestorNamed(t){return this._bindingWhenSyntax.whenAnyAncestorNamed(t)}whenAnyAncestorTagged(t,n){return this._bindingWhenSyntax.whenAnyAncestorTagged(t,n)}whenNoAncestorNamed(t){return this._bindingWhenSyntax.whenNoAncestorNamed(t)}whenNoAncestorTagged(t,n){return this._bindingWhenSyntax.whenNoAncestorTagged(t,n)}whenAnyAncestorMatches(t){return this._bindingWhenSyntax.whenAnyAncestorMatches(t)}whenNoAncestorMatches(t){return this._bindingWhenSyntax.whenNoAncestorMatches(t)}onActivation(t){return this._bindingOnSyntax.onActivation(t)}onDeactivation(t){return this._bindingOnSyntax.onDeactivation(t)}}class Nt{_binding;constructor(t){this._binding=t}inRequestScope(){return this._binding.scope=v.Request,new Dt(this._binding)}inSingletonScope(){return this._binding.scope=v.Singleton,new Dt(this._binding)}inTransientScope(){return this._binding.scope=v.Transient,new Dt(this._binding)}}class Ct{_bindingInSyntax;_bindingWhenSyntax;_bindingOnSyntax;_binding;constructor(t){this._binding=t,this._bindingWhenSyntax=new It(this._binding),this._bindingOnSyntax=new Tt(this._binding),this._bindingInSyntax=new Nt(t)}inRequestScope(){return this._bindingInSyntax.inRequestScope()}inSingletonScope(){return this._bindingInSyntax.inSingletonScope()}inTransientScope(){return this._bindingInSyntax.inTransientScope()}when(t){return this._bindingWhenSyntax.when(t)}whenTargetNamed(t){return this._bindingWhenSyntax.whenTargetNamed(t)}whenTargetIsDefault(){return this._bindingWhenSyntax.whenTargetIsDefault()}whenTargetTagged(t,n){return this._bindingWhenSyntax.whenTargetTagged(t,n)}whenInjectedInto(t){return this._bindingWhenSyntax.whenInjectedInto(t)}whenParentNamed(t){return this._bindingWhenSyntax.whenParentNamed(t)}whenParentTagged(t,n){return this._bindingWhenSyntax.whenParentTagged(t,n)}whenAnyAncestorIs(t){return this._bindingWhenSyntax.whenAnyAncestorIs(t)}whenNoAncestorIs(t){return this._bindingWhenSyntax.whenNoAncestorIs(t)}whenAnyAncestorNamed(t){return this._bindingWhenSyntax.whenAnyAncestorNamed(t)}whenAnyAncestorTagged(t,n){return this._bindingWhenSyntax.whenAnyAncestorTagged(t,n)}whenNoAncestorNamed(t){return this._bindingWhenSyntax.whenNoAncestorNamed(t)}whenNoAncestorTagged(t,n){return this._bindingWhenSyntax.whenNoAncestorTagged(t,n)}whenAnyAncestorMatches(t){return this._bindingWhenSyntax.whenAnyAncestorMatches(t)}whenNoAncestorMatches(t){return this._bindingWhenSyntax.whenNoAncestorMatches(t)}onActivation(t){return this._bindingOnSyntax.onActivation(t)}onDeactivation(t){return this._bindingOnSyntax.onDeactivation(t)}}class xt{_binding;constructor(t){this._binding=t}to(t){return this._binding.type=b.Instance,this._binding.implementationType=t,new Ct(this._binding)}toSelf(){if("function"!=typeof this._binding.serviceIdentifier)throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");const t=this._binding.serviceIdentifier;return this.to(t)}toConstantValue(t){return this._binding.type=b.ConstantValue,this._binding.cache=t,this._binding.dynamicValue=null,this._binding.implementationType=null,this._binding.scope=v.Singleton,new Dt(this._binding)}toDynamicValue(t){return this._binding.type=b.DynamicValue,this._binding.cache=null,this._binding.dynamicValue=t,this._binding.implementationType=null,new Ct(this._binding)}toConstructor(t){return this._binding.type=b.Constructor,this._binding.implementationType=t,this._binding.scope=v.Singleton,new Dt(this._binding)}toFactory(t){return this._binding.type=b.Factory,this._binding.factory=t,this._binding.scope=v.Singleton,new Dt(this._binding)}toFunction(t){if("function"!=typeof t)throw new Error("Value provided to function binding must be a function!");const n=this.toConstantValue(t);return this._binding.type=b.Function,this._binding.scope=v.Singleton,n}toAutoFactory(t){return this._binding.type=b.Factory,this._binding.factory=n=>()=>n.container.get(t),this._binding.scope=v.Singleton,new Dt(this._binding)}toAutoNamedFactory(t){return this._binding.type=b.Factory,this._binding.factory=n=>e=>n.container.getNamed(t,e),new Dt(this._binding)}toProvider(t){return this._binding.type=b.Provider,this._binding.provider=t,this._binding.scope=v.Singleton,new Dt(this._binding)}toService(t){this._binding.type=b.DynamicValue,Object.defineProperty(this._binding,"cache",{configurable:!0,enumerable:!0,get:()=>null,set(t){}}),this._binding.dynamicValue=n=>{try{return n.container.get(t)}catch(e){return n.container.getAsync(t)}},this._binding.implementationType=null}}class Rt{bindings;activations;deactivations;middleware;moduleActivationStore;static of(t,n,e,i,r){const s=new Rt;return s.bindings=t,s.middleware=n,s.deactivations=i,s.activations=e,s.moduleActivationStore=r,s}}class Et{_map;constructor(){this._map=new Map}getMap(){return this._map}add(t,n){if(this._checkNonNulish(t),null==n)throw new Error(T);const e=this._map.get(t);void 0!==e?e.push(n):this._map.set(t,[n])}get(t){this._checkNonNulish(t);const n=this._map.get(t);if(void 0!==n)return n;throw new Error(D)}remove(t){if(this._checkNonNulish(t),!this._map.delete(t))throw new Error(D)}removeIntersection(t){this.traverse(((n,e)=>{const i=t.hasKey(n)?t.get(n):void 0;if(void 0!==i){const t=e.filter((t=>!i.some((n=>t===n))));this._setValue(n,t)}}))}removeByCondition(t){const n=[];return this._map.forEach(((e,i)=>{const r=[];for(const i of e){t(i)?n.push(i):r.push(i)}this._setValue(i,r)})),n}hasKey(t){return this._checkNonNulish(t),this._map.has(t)}clone(){const t=new Et;return this._map.forEach(((n,e)=>{n.forEach((n=>{var i;t.add(e,"object"==typeof(i=n)&&null!==i&&"clone"in i&&"function"==typeof i.clone?n.clone():n)}))})),t}traverse(t){this._map.forEach(((n,e)=>{t(e,n)}))}_checkNonNulish(t){if(null==t)throw new Error(T)}_setValue(t,n){n.length>0?this._map.set(t,n):this._map.delete(t)}}class Mt{_map=new Map;remove(t){const n=this._map.get(t);return void 0===n?this._getEmptyHandlersStore():(this._map.delete(t),n)}addDeactivation(t,n,e){this._getModuleActivationHandlers(t).onDeactivations.add(n,e)}addActivation(t,n,e){this._getModuleActivationHandlers(t).onActivations.add(n,e)}clone(){const t=new Mt;return this._map.forEach(((n,e)=>{t._map.set(e,{onActivations:n.onActivations.clone(),onDeactivations:n.onDeactivations.clone()})})),t}_getModuleActivationHandlers(t){let n=this._map.get(t);return void 0===n&&(n=this._getEmptyHandlersStore(),this._map.set(t,n)),n}_getEmptyHandlersStore(){return{onActivations:new Et,onDeactivations:new Et}}}class Bt{id;parent;options;_middleware;_bindingDictionary;_activations;_deactivations;_snapshots;_metadataReader;_moduleActivationStore;constructor(t){const n=t||{};if("object"!=typeof n)throw new Error("Invalid Container constructor argument. Container options must be an object.");if(void 0===n.defaultScope)n.defaultScope=v.Transient;else if(n.defaultScope!==v.Singleton&&n.defaultScope!==v.Transient&&n.defaultScope!==v.Request)throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');if(void 0===n.autoBindInjectable)n.autoBindInjectable=!1;else if("boolean"!=typeof n.autoBindInjectable)throw new Error("Invalid Container option. Auto bind injectable must be a boolean");if(void 0===n.skipBaseClassChecks)n.skipBaseClassChecks=!1;else if("boolean"!=typeof n.skipBaseClassChecks)throw new Error("Invalid Container option. Skip base check must be a boolean");this.options={autoBindInjectable:n.autoBindInjectable,defaultScope:n.defaultScope,skipBaseClassChecks:n.skipBaseClassChecks},this.id=A(),this._bindingDictionary=new Et,this._snapshots=[],this._middleware=null,this._activations=new Et,this._deactivations=new Et,this.parent=null,this._metadataReader=new E,this._moduleActivationStore=new Mt}static merge(t,n,...e){const i=new Bt,r=[t,n,...e].map((t=>H(t))),s=H(i);return r.forEach((t=>{var n;n=s,t.traverse(((t,e)=>{e.forEach((t=>{n.add(t.serviceIdentifier,t.clone())}))}))})),i}load(...t){const n=this._getContainerModuleHelpersFactory();for(const e of t){const t=n(e.id);e.registry(t.bindFunction,t.unbindFunction,t.isboundFunction,t.rebindFunction,t.unbindAsyncFunction,t.onActivationFunction,t.onDeactivationFunction)}}async loadAsync(...t){const n=this._getContainerModuleHelpersFactory();for(const e of t){const t=n(e.id);await e.registry(t.bindFunction,t.unbindFunction,t.isboundFunction,t.rebindFunction,t.unbindAsyncFunction,t.onActivationFunction,t.onDeactivationFunction)}}unload(...t){t.forEach((t=>{const n=this._removeModuleBindings(t.id);this._deactivateSingletons(n),this._removeModuleHandlers(t.id)}))}async unloadAsync(...t){for(const n of t){const t=this._removeModuleBindings(n.id);await this._deactivateSingletonsAsync(t),this._removeModuleHandlers(n.id)}}bind(t){return this._bind(this._buildBinding(t))}rebind(t){return this.unbind(t),this.bind(t)}async rebindAsync(t){return await this.unbindAsync(t),this.bind(t)}unbind(t){if(this._bindingDictionary.hasKey(t)){const n=this._bindingDictionary.get(t);this._deactivateSingletons(n)}this._removeServiceFromDictionary(t)}async unbindAsync(t){if(this._bindingDictionary.hasKey(t)){const n=this._bindingDictionary.get(t);await this._deactivateSingletonsAsync(n)}this._removeServiceFromDictionary(t)}unbindAll(){this._bindingDictionary.traverse(((t,n)=>{this._deactivateSingletons(n)})),this._bindingDictionary=new Et}async unbindAllAsync(){const t=[];this._bindingDictionary.traverse(((n,e)=>{t.push(this._deactivateSingletonsAsync(e))})),await Promise.all(t),this._bindingDictionary=new Et}onActivation(t,n){this._activations.add(t,n)}onDeactivation(t,n){this._deactivations.add(t,n)}isBound(t){let n=this._bindingDictionary.hasKey(t);return!n&&this.parent&&(n=this.parent.isBound(t)),n}isCurrentBound(t){return this._bindingDictionary.hasKey(t)}isBoundNamed(t,n){return this.isBoundTagged(t,r,n)}isBoundTagged(t,r,s){let o=!1;if(this._bindingDictionary.hasKey(t)){const a=this._bindingDictionary.get(t),c=function(t,r,s){const o=L(r,s),a=n(o);if(a.kind===e.unmanaged)throw new Error("Unexpected metadata when creating target");const c=new i("",a,"Variable"),d=new $(t);return new K(r,d,null,[],c)}(this,t,{customTag:{key:r,value:s},isMultiInject:!1});o=a.some((t=>t.constraint(c)))}return!o&&this.parent&&(o=this.parent.isBoundTagged(t,r,s)),o}snapshot(){this._snapshots.push(Rt.of(this._bindingDictionary.clone(),this._middleware,this._activations.clone(),this._deactivations.clone(),this._moduleActivationStore.clone()))}restore(){const t=this._snapshots.pop();if(void 0===t)throw new Error("No snapshot available to restore.");this._bindingDictionary=t.bindings,this._activations=t.activations,this._deactivations=t.deactivations,this._middleware=t.middleware,this._moduleActivationStore=t.moduleActivationStore}createChild(t){const n=new Bt(t||this.options);return n.parent=this,n}applyMiddleware(...t){const n=this._middleware?this._middleware:this._planAndResolve();this._middleware=t.reduce(((t,n)=>n(t)),n)}applyCustomMetadataReader(t){this._metadataReader=t}get(t){const n=this._getNotAllArgs(t,!1,!1);return this._getButThrowIfAsync(n)}async getAsync(t){const n=this._getNotAllArgs(t,!1,!1);return this._get(n)}getTagged(t,n,e){const i=this._getNotAllArgs(t,!1,!1,n,e);return this._getButThrowIfAsync(i)}async getTaggedAsync(t,n,e){const i=this._getNotAllArgs(t,!1,!1,n,e);return this._get(i)}getNamed(t,n){return this.getTagged(t,r,n)}async getNamedAsync(t,n){return this.getTaggedAsync(t,r,n)}getAll(t,n){const e=this._getAllArgs(t,n,!1);return this._getButThrowIfAsync(e)}async getAllAsync(t,n){const e=this._getAllArgs(t,n,!1);return this._getAll(e)}getAllTagged(t,n,e){const i=this._getNotAllArgs(t,!0,!1,n,e);return this._getButThrowIfAsync(i)}async getAllTaggedAsync(t,n,e){const i=this._getNotAllArgs(t,!0,!1,n,e);return this._getAll(i)}getAllNamed(t,n){return this.getAllTagged(t,r,n)}async getAllNamedAsync(t,n){return this.getAllTaggedAsync(t,r,n)}resolve(t){const n=this.isBound(t);n||this.bind(t).toSelf();const e=this.get(t);return n||this.unbind(t),e}tryGet(t){const n=this._getNotAllArgs(t,!1,!0);return this._getButThrowIfAsync(n)}async tryGetAsync(t){const n=this._getNotAllArgs(t,!1,!0);return this._get(n)}tryGetTagged(t,n,e){const i=this._getNotAllArgs(t,!1,!0,n,e);return this._getButThrowIfAsync(i)}async tryGetTaggedAsync(t,n,e){const i=this._getNotAllArgs(t,!1,!0,n,e);return this._get(i)}tryGetNamed(t,n){return this.tryGetTagged(t,r,n)}async tryGetNamedAsync(t,n){return this.tryGetTaggedAsync(t,r,n)}tryGetAll(t,n){const e=this._getAllArgs(t,n,!0);return this._getButThrowIfAsync(e)}async tryGetAllAsync(t,n){const e=this._getAllArgs(t,n,!0);return this._getAll(e)}tryGetAllTagged(t,n,e){const i=this._getNotAllArgs(t,!0,!0,n,e);return this._getButThrowIfAsync(i)}async tryGetAllTaggedAsync(t,n,e){const i=this._getNotAllArgs(t,!0,!0,n,e);return this._getAll(i)}tryGetAllNamed(t,n){return this.tryGetAllTagged(t,r,n)}async tryGetAllNamedAsync(t,n){return this.tryGetAllTaggedAsync(t,r,n)}_preDestroy(t,n){if(void 0!==t&&Reflect.hasMetadata(p,t)){const e=Reflect.getMetadata(p,t);return n[e.value]?.()}}_removeModuleHandlers(t){const n=this._moduleActivationStore.remove(t);this._activations.removeIntersection(n.onActivations),this._deactivations.removeIntersection(n.onDeactivations)}_removeModuleBindings(t){return this._bindingDictionary.removeByCondition((n=>n.moduleId===t))}_deactivate(t,n){const e=null==n?void 0:Object.getPrototypeOf(n).constructor;try{if(this._deactivations.hasKey(t.serviceIdentifier)){const i=this._deactivateContainer(n,this._deactivations.get(t.serviceIdentifier).values());if(Q(i))return this._handleDeactivationError(i.then((async()=>this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(t,n,e))),t.serviceIdentifier)}const i=this._propagateContainerDeactivationThenBindingAndPreDestroy(t,n,e);if(Q(i))return this._handleDeactivationError(i,t.serviceIdentifier)}catch(n){if(n instanceof Error)throw new Error(R(P(t.serviceIdentifier),n.message))}}async _handleDeactivationError(t,n){try{await t}catch(t){if(t instanceof Error)throw new Error(R(P(n),t.message))}}_deactivateContainer(t,n){let e=n.next();for(;"function"==typeof e.value;){const i=e.value(t);if(Q(i))return i.then((async()=>this._deactivateContainerAsync(t,n)));e=n.next()}}async _deactivateContainerAsync(t,n){let e=n.next();for(;"function"==typeof e.value;)await e.value(t),e=n.next()}_getContainerModuleHelpersFactory(){const t=t=>n=>{const e=this._buildBinding(n);return e.moduleId=t,this._bind(e)},n=()=>t=>{this.unbind(t)},e=()=>async t=>this.unbindAsync(t),i=()=>t=>this.isBound(t),r=n=>{const e=t(n);return t=>(this.unbind(t),e(t))},s=t=>(n,e)=>{this._moduleActivationStore.addActivation(t,n,e),this.onActivation(n,e)},o=t=>(n,e)=>{this._moduleActivationStore.addDeactivation(t,n,e),this.onDeactivation(n,e)};return a=>({bindFunction:t(a),isboundFunction:i(),onActivationFunction:s(a),onDeactivationFunction:o(a),rebindFunction:r(a),unbindAsyncFunction:e(),unbindFunction:n()})}_bind(t){return this._bindingDictionary.add(t.serviceIdentifier,t),new xt(t)}_buildBinding(t){const n=this.options.defaultScope||v.Transient;return new S(t,n)}async _getAll(t){return Promise.all(this._get(t))}_get(t){const n={...t,contextInterceptor:t=>t,targetType:w.Variable};if(this._middleware){const t=this._middleware(n);if(null==t)throw new Error("Invalid return type in middleware. Middleware must return!");return t}return this._planAndResolve()(n)}_getButThrowIfAsync(t){const n=this._get(t);if(X(n))throw new Error(`You are attempting to construct ${function(t){return"function"==typeof t?`[function/class ${t.name||"<anonymous>"}]`:"symbol"==typeof t?t.toString():`'${t}'`}(t.serviceIdentifier)} in a synchronous way but it has asynchronous dependencies.`);return n}_getAllArgs(t,n,e){return{avoidConstraints:!n?.enforceBindingConstraints,isMultiInject:!0,isOptional:e,serviceIdentifier:t}}_getNotAllArgs(t,n,e,i,r){return{avoidConstraints:!1,isMultiInject:n,isOptional:e,key:i,serviceIdentifier:t,value:r}}_getPlanMetadataFromNextArgs(t){const n={isMultiInject:t.isMultiInject};return void 0!==t.key&&(n.customTag={key:t.key,value:t.value}),!0===t.isOptional&&(n.isOptional=!0),n}_planAndResolve(){return t=>{let n=J(this._metadataReader,this,t.targetType,t.serviceIdentifier,this._getPlanMetadataFromNextArgs(t),t.avoidConstraints);n=t.contextInterceptor(n);const e=function(t){return dt(t.plan.rootRequest.requestScope)(t.plan.rootRequest)}(n);return e}}_deactivateIfSingleton(t){if(t.activated)return Q(t.cache)?t.cache.then((n=>this._deactivate(t,n))):this._deactivate(t,t.cache)}_deactivateSingletons(t){for(const n of t){if(Q(this._deactivateIfSingleton(n)))throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)")}}async _deactivateSingletonsAsync(t){await Promise.all(t.map((async t=>this._deactivateIfSingleton(t))))}_propagateContainerDeactivationThenBindingAndPreDestroy(t,n,e){return this.parent?this._deactivate.bind(this.parent)(t,n):this._bindingDeactivationAndPreDestroy(t,n,e)}async _propagateContainerDeactivationThenBindingAndPreDestroyAsync(t,n,e){this.parent?await this._deactivate.bind(this.parent)(t,n):await this._bindingDeactivationAndPreDestroyAsync(t,n,e)}_removeServiceFromDictionary(t){try{this._bindingDictionary.remove(t)}catch(n){throw new Error(`Could not unbind serviceIdentifier: ${P(t)}`)}}_bindingDeactivationAndPreDestroy(t,n,e){if("function"==typeof t.onDeactivation){const i=t.onDeactivation(n);if(Q(i))return i.then((()=>this._preDestroy(e,n)))}return this._preDestroy(e,n)}async _bindingDeactivationAndPreDestroyAsync(t,n,e){"function"==typeof t.onDeactivation&&await t.onDeactivation(n),await this._preDestroy(e,n)}}class Pt{id;registry;constructor(t){this.id=A(),this.registry=t}}class kt{id;registry;constructor(t){this.id=A(),this.registry=t}}function qt(t,n,e,i){!function(t){if(void 0!==t)throw new Error(x)}(n),jt(u,t,e.toString(),i)}function Ft(t){let n=[];if(Array.isArray(t)){n=t;const e=function(t){const n=new Set;for(const e of t){if(n.has(e))return e;n.add(e)}}(n.map((t=>t.key)));if(void 0!==e)throw new Error(`${I} ${e.toString()}`)}else n=[t];return n}function jt(t,n,e,i){const r=Ft(i);let s={};Reflect.hasOwnMetadata(t,n)&&(s=Reflect.getMetadata(t,n));let o=s[e];if(void 0===o)o=[];else for(const t of o)if(r.some((n=>n.key===t.key)))throw new Error(`${I} ${t.key.toString()}`);o.push(...r),s[e]=o,Reflect.defineMetadata(t,s,n)}function Ot(t){return(n,e,i)=>{"number"==typeof i?qt(n,e,i,t):function(t,n,e){if(void 0!==t.prototype)throw new Error(x);jt(h,t.constructor,n,e)}(n,e,t)}}function $t(t,n){Reflect.decorate(t,n)}function Vt(t,n){return function(e,i){n(e,i,t)}}function Wt(t,n,e){"number"==typeof e?$t([Vt(e,t)],n):"string"==typeof e?Reflect.decorate([t],n,e):$t([t],n)}function Gt(){return function(t){if(Reflect.hasOwnMetadata(l,t))throw new Error("Cannot apply @injectable decorator multiple times.");const n=Reflect.getMetadata(g,t)||[];return Reflect.defineMetadata(l,n,t),t}}function Kt(t,n){return Ot(new V(t,n))}function Ht(t){return Ot(new V(r,t))}function Ut(t){return n=>(e,i,r)=>{if(void 0===n){const t="function"==typeof e?e.name:e.constructor.name;throw new Error(`@inject called with undefined this could mean that the class ${t} has a circular dependency problem. You can use a LazyServiceIdentifer to overcome this limitation.`)}Ot(new V(t,n))(e,i,r)}}const Lt=Ut(c);function Yt(){return Ot(new V(a,!0))}function zt(){return function(t,n,e){qt(t,n,e,new V(o,!0))}}const Jt=Ut(d);function Qt(t){return function(n,e,i){qt(n,e,i,new V(s,t))}}function Xt(t,n){return()=>(e,i)=>{const r=new V(t,i);if(Reflect.hasOwnMetadata(t,e.constructor))throw new Error(n);Reflect.defineMetadata(t,r,e.constructor)}}const Zt=Xt(y,"Cannot apply @postConstruct decorator multiple times in the same class"),tn=Xt(p,"Cannot apply @preDestroy decorator multiple times in the same class"),nn=_;export{kt as AsyncContainerModule,v as BindingScopeEnum,b as BindingTypeEnum,Bt as Container,Pt as ContainerModule,nn as METADATA_KEY,E as MetadataReader,w as TargetTypeEnum,Ot as createTaggedDecorator,Wt as decorate,P as getServiceIdentifierAsString,A as id,Lt as inject,Gt as injectable,it as multiBindToService,Jt as multiInject,Ht as named,At as namedConstraint,Yt as optional,Zt as postConstruct,tn as preDestroy,Kt as tagged,mt as taggedConstraint,Qt as targetName,wt as traverseAncerstors,St as typeConstraint,zt as unmanaged};
//# sourceMappingURL=index.js.map
